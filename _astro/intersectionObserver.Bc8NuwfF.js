import{a as l}from"./index.3whys8t3.js";function n(){return n=Object.assign?Object.assign.bind():function(i){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var t in s)({}).hasOwnProperty.call(s,t)&&(i[t]=s[t])}return i},n.apply(null,arguments)}class o{static init({rootMargin:e=this.defaultRootMargin,callback:s}={}){this.defaultRootMargin=e,this.observeAll(),window.dispatchEvent(new CustomEvent(this.CONFIG.EVENTS.READY)),s?.()}static destroy({callback:e}={}){this.observers.forEach(s=>s.disconnect()),this.observers.clear(),this.observedElements.clear(),window.dispatchEvent(new CustomEvent(this.CONFIG.EVENTS.DESTROYED)),e?.()}static observe(e,s,t){if(this.observedElements.has(e))return;const r=s||t?this.getElementConfigWithOverrides(e,s,t):this.getElementConfig(e),a=this.getOrCreateObserver(r.rootMargin);this.observedElements.set(e,r),a.observe(e)}static unobserve(e){const s=this.observedElements.get(e);if(!s)return;const t=this.observers.get(s.rootMargin);t&&t.unobserve(e),this.observedElements.delete(e)}static refresh(){const e=[];this.observedElements.forEach((s,t)=>{document.body.contains(t)||e.push(t)}),e.forEach(s=>this.unobserve(s)),this.observeAll()}static getStats(){return{observerCount:this.observers.size,elementCount:this.observedElements.size,rootMargins:Array.from(this.observers.keys())}}static getOrCreateObserver(e){if(!this.observers.has(e)){const s=new IntersectionObserver(t=>this.handleIntersection(t),{rootMargin:e,threshold:0});this.observers.set(e,s)}return this.observers.get(e)}static observeAll(){document.querySelectorAll(`[${this.CONFIG.ATTRIBUTES.TRIGGER}]`).forEach(e=>this.observe(e))}static getElementConfig(e){const s=e.getAttribute(this.CONFIG.ATTRIBUTES.ROOT_MARGIN)||this.defaultRootMargin;return{className:e.getAttribute(this.CONFIG.ATTRIBUTES.CLASS)||this.CONFIG.DEFAULT_CLASS,shouldToggle:e.hasAttribute(this.CONFIG.ATTRIBUTES.TOGGLE),rootMargin:s}}static getElementConfigWithOverrides(e,s,t){return n({},this.getElementConfig(e),t?.className&&{className:t.className},t?.shouldToggle!==void 0&&{shouldToggle:t.shouldToggle},t?.rootMargin&&{rootMargin:t.rootMargin},s&&{callback:s})}static handleIntersection(e){e.forEach(s=>{const t=this.observedElements.get(s.target);if(!t)return;const r=s.isIntersecting;t.callback&&t.callback(s,r),r?(s.target.classList.add(t.className),t.shouldToggle||this.unobserve(s.target)):t.shouldToggle&&s.target.classList.remove(t.className)})}}o.observers=new Map,o.observedElements=new Map,o.defaultRootMargin="0px 0px 0px 0px",o.CONFIG={ATTRIBUTES:{TRIGGER:"data-inview",CLASS:"data-inview-class",TOGGLE:"data-inview-toggle",ROOT_MARGIN:"data-inview-root-margin"},DEFAULT_CLASS:"is-inview",EVENTS:{READY:"intersectionObserverManager:ready",DESTROYED:"intersectionObserverManager:destroyed"}};const h=l(!1);export{h as $,o as t};
