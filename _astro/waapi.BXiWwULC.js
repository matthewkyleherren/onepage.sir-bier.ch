import{c as ct,r as ut,d as ht,e as ft,f as dt,g as _,v as K,h as f,j as mt,k as h,l as p,n as z,t as pt,m as T,o as yt,q as gt,u as vt,w as et,x as St,y as D,z as st,K as H,A as q,i as J,B as nt}from"./targets.Ch0TkwgG.js";import{p as At,n as bt}from"./parser.BX5Tv8gU.js";/**
 * Anime.js - waapi - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */const X={_head:null,_tail:null},Q=(s,t,e)=>{let n=X._head,i;for(;n;){const r=n._next,l=n.$el===s,c=!t||n.property===t,v=!e||n.parent===e;if(l&&c&&v){i=n.animation;try{i.commitStyles()}catch{}i.cancel(),ut(X,n);const u=n.parent;u&&(u._completed++,u.animations.length===u._completed&&(u.completed=!0,u.paused=!0,u.muteCallbacks||(u.onComplete(u),u._resolve(u))))}n=r}return i},N=(s,t,e,n,i)=>{const r=t.animate(n,i),l=i.delay+ +i.duration*i.iterations;r.playbackRate=s._speed,s.paused&&r.pause(),s.duration<l&&(s.duration=l,s.controlAnimation=r),s.animations.push(r),Q(t,e),ct(X,{parent:s,animation:r,$el:t,property:e,_next:null,_prev:null});const c=()=>{Q(t,e,s)};return r.oncancel=c,r.onremove=c,s.persist||(r.onfinish=c),r};/**
 * Anime.js - waapi - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */const V=(s,t=100)=>{const e=[];for(let n=0;n<=t;n++)e.push(ht(s(n/t),4));return`linear(${e.join(", ")})`},$={},L=s=>{let t=$[s];if(t)return t;if(t="linear",q(s)){if(f(s,"linear")||f(s,"cubic-")||f(s,"steps")||f(s,"ease"))t=s;else if(f(s,"cubicB"))t=st(s);else{const e=At(s);J(e)&&(t=e===bt?"linear":V(e))}$[s]=t}else if(J(s)){const e=V(s);e&&(t=e)}else s.ease&&(t=V(s.ease));return t},it=["x","y","z"],kt=["perspective","width","height","margin","padding","top","right","bottom","left","borderWidth","fontSize","borderRadius",...it],wt=[...it,...K.filter(s=>["X","Y","Z"].some(t=>s.endsWith(t)))];let B=null;const E=(s,t,e,n,i)=>{let r=q(t)?t:T(t,e,n,i);return nt(r)?kt.includes(s)||f(s,"translate")?`${r}px`:f(s,"rotate")||f(s,"skew")?`${r}deg`:`${r}`:r},tt=(s,t,e,n,i,r)=>{let l="0";const c=_(n)?getComputedStyle(s)[t]:E(t,n,s,i,r);return _(e)?l=et(n)?n.map(v=>E(t,v,s,i,r)):c:l=[E(t,e,s,i,r),c],l};class Pt{constructor(t,e){ft(B)&&(dt&&(_(CSS)||!Object.hasOwnProperty.call(CSS,"registerProperty"))?B=!1:(K.forEach(a=>{const d=f(a,"skew"),b=f(a,"scale"),x=f(a,"rotate"),S=f(a,"translate"),w=x||d,R=w?"<angle>":b?"<number>":S?"<length-percentage>":"*";try{CSS.registerProperty({name:"--"+a,syntax:R,inherits:!1,initialValue:S?"0px":w?"0deg":b?"1":"0"})}catch{}}),B=!0));const n=mt(t),i=n.length;i||console.warn("No target found. Make sure the element you're trying to animate is accessible before creating your animation.");const r=h(e.ease,L(p.defaults.ease)),l=r.ease&&r,c=h(e.autoplay,p.defaults.autoplay),v=c&&c.link?c:!1,u=e.alternate&&e.alternate===!0,W=e.reversed&&e.reversed===!0,C=h(e.loop,p.defaults.loop),rt=C===!0||C===1/0?1/0:nt(C)?C+1:1,ot=u?W?"alternate-reverse":"alternate":W?"reverse":"normal",at="both",lt=L(r),I=p.timeScale===1?1:H;this.targets=n,this.animations=[],this.controlAnimation=null,this.onComplete=e.onComplete||p.defaults.onComplete,this.duration=0,this.muteCallbacks=!1,this.completed=!1,this.paused=!c||v!==!1,this.reversed=W,this.persist=h(e.persist,p.defaults.persist),this.autoplay=c,this._speed=h(e.playbackRate,p.defaults.playbackRate),this._resolve=z,this._completed=0,this._inlineStyles=[],n.forEach((a,d)=>{const b=a[pt],x=wt.some(o=>e.hasOwnProperty(o)),S=a.style,w=this._inlineStyles[d]={},R=(l?l.settlingDuration:T(h(e.duration,p.defaults.duration),a,d,i))*I,M=T(h(e.delay,p.defaults.delay),a,d,i)*I,U=h(e.composition,"replace");for(let o in e){if(!yt(o))continue;const m={},k={iterations:rt,direction:ot,fill:at,easing:lt,duration:R,delay:M,composite:U},P=e[o],y=x?K.includes(o)?o:gt.get(o):!1,O=y?"transform":o;w[O]||(w[O]=S[O]);let A;if(vt(P)){const g=P,F=h(g.ease,r),Y=F.ease&&F,Z=g.to,j=g.from;if(k.duration=(Y?Y.settlingDuration:T(h(g.duration,R),a,d,i))*I,k.delay=T(h(g.delay,M),a,d,i)*I,k.composite=h(g.composition,U),k.easing=L(F),A=tt(a,o,j,Z,d,i),y?(m[`--${y}`]=A,b[y]=A):m[o]=tt(a,o,j,Z,d,i),N(this,a,o,m,k),!_(j))if(!y)S[o]=m[o][0];else{const G=`--${y}`;S.setProperty(G,m[G][0])}}else A=et(P)?P.map(g=>E(o,g,a,d,i)):E(o,P,a,d,i),y?(m[`--${y}`]=A,b[y]=A):m[o]=A,N(this,a,o,m,k)}if(x){let o=D;for(let m in b)o+=`${St[m]}var(--${m})) `;S.transform=o}}),v&&this.autoplay.link(this)}forEach(t){const e=q(t)?n=>n[t]():t;return this.animations.forEach(e),this}get speed(){return this._speed}set speed(t){this._speed=+t,this.forEach(e=>e.playbackRate=t)}get currentTime(){const t=this.controlAnimation,e=p.timeScale;return this.completed?this.duration:t?+t.currentTime*(e===1?1:e):0}set currentTime(t){const e=t*(p.timeScale===1?1:H);this.forEach(n=>{!this.persist&&e>=this.duration&&n.play(),n.currentTime=e})}get progress(){return this.currentTime/this.duration}set progress(t){this.forEach(e=>e.currentTime=t*this.duration||0)}resume(){return this.paused?(this.paused=!1,this.forEach("play")):this}pause(){return this.paused?this:(this.paused=!0,this.forEach("pause"))}alternate(){return this.reversed=!this.reversed,this.forEach("reverse"),this.paused&&this.forEach("pause"),this}play(){return this.reversed&&this.alternate(),this.resume()}reverse(){return this.reversed||this.alternate(),this.resume()}seek(t,e=!1){return e&&(this.muteCallbacks=!0),t<this.duration&&(this.completed=!1),this.currentTime=t,this.muteCallbacks=!1,this.paused&&this.pause(),this}restart(){return this.completed=!1,this.seek(0,!0).resume()}commitStyles(){return this.forEach("commitStyles")}complete(){return this.seek(this.duration)}cancel(){return this.muteCallbacks=!0,this.commitStyles().forEach("cancel")}revert(){return this.cancel().targets.forEach((t,e)=>{const n=t.style,i=this._inlineStyles[e];for(let r in i){const l=i[r];_(l)||l===D?n.removeProperty(st(r)):n[r]=l}t.getAttribute("style")===D&&t.removeAttribute("style")}),this}then(t=z){const e=this.then,n=()=>{this.then=null,t(this),this.then=e,this._resolve=z};return new Promise(i=>(this._resolve=()=>i(n()),this.completed&&this._resolve(),this))}}const Et={animate:(s,t)=>new Pt(s,t),convertEase:V};export{Et as w};
